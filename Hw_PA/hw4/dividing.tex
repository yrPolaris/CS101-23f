\titledquestion{Dividing with Creativity}

In this question, you are required analyze the run-time of algorithms with different dividing methods mentioned below. For each subpart except the third one, your answer should include:
\begin{enumerate}
    \item Describing the recurrence relation of the run-time $T(n)$. (Worth 1 point in 4)
    \item Finding the asymptotic order of the growth of $T(n)$ i.e. find a function $g$ such that $T(n) = O(g(n))$. Make sure your upper bound for $T(n)$ is tight enough. (Worth 1 point in 4)
    \item Show your \textbf{reasoning} for the upper bound of $T(n)$ or your process of obtaining the upper bound starting from the recurrence relation step by step. (Worth 2 points in 4)
\end{enumerate}

In each subpart, you may ignore any issue arising from whether a number is an integer as well as assuming \(T(0) = 0\) and \(T(1) = 1\). You can make use of the Master Theorem, Recursion Tree or other reasonable approaches to solve the following recurrence relations.

\begin{parts}
    \part[4] An algorithm $\mathcal{A}_1$ takes $\Theta(n)$ time to partition the original problem into 2 sub-problems, one of size $\lambda n$ and the other of size $(1-\lambda)n$ (here $\lambda \in \left(0, \frac{1}{2}\right)$), then recursively runs itself on both of the 2 sub-problems and finally takes $\Theta(n)$ time to merge the answers of the 2 sub-problems.
    
    \begin{solution}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Replace `\vspace{5in}' with your answer.
    \\
    1.T(n) = T($\lambda$n) + T($(1-\lambda)n$) + $\theta(n)$\\
    2.T(n) = $O$(nlogn)\\
    3.Reason:\\
        because $A_{1}$ takes $\theta(n)$ time to partition the original problem into 2 sub-problem, and the size is $\lambda$ and $1-\lambda$ then the sub-problem naturally takes $\theta(\lambda(n))$, $\theta((1-\lambda)n)$. To ensure on the kth level, all the sub-pronblem is solved on constant time, (because $\lambda$ < $\frac{1}{2}$)then $(1 - \lambda)^{k} = \frac{1}{n}$ i.e.$k = log_{1-\lambda}(\frac{1}{n})$.\\
        So the zero level is n, then the 1th level is $\lambda(n)$, $(1-\lambda)n$, the 2nd level is $\lambda^{2}(n)$, $\lambda(1-\lambda)n$, $(1-\lambda)^{2}n$ ... So the total work T(n) = $\sum_{i=0}^{log_{1-\lambda}\frac{1}{n}}\sum_{j=0}^{i}C_{i}^{j}\lambda^{j}(1-\lambda)^{i-j}n$ = $\sum_{i=0}^{log_{1-\lambda}\frac{1}{n}}n = nlog_{1-\lambda}\frac{1}{n}$ and $\lambda \in (0, \frac{1}{2})$\\
        Therefore, the result  of T(n) is $O$(nlogn)\\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    \end{solution}

    \newpage
    
    \part[4] An algorithm $\mathcal{A}_2$ takes $\Theta(n)$ time to partition the original problem into 2 sub-problems, one of size $k$ and the other of size $(n - k)$ (here $k \in \mathbb{Z}^+$ is a constant), then recursively runs itself on both of the 2 sub-problems and finally takes $\Theta(n)$ time to merge the answers of the 2 sub-problems.
    
    \begin{solution}\\
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Replace `\vspace{1.5in}' with your answer.
    1.T(n) = T(n-k) + T(k) + $\theta(n)$\\
    2.T(n) = $\theta$($n^{2}$)\\
    3.from the zero level, to the 1st level, because one of size k and the other of size(n-k) and k is a constant, then the k size sub-problem can be solved in consant time which is $\theta(1)$ and don't need to partition next(since it has been solved).\\
    Then according to recursive tree, the size n-k sub-problem will be partitioned into size k and size n-2k with $\theta(n-k)$ time, and repeat the process above.\\
    Then we get the following series T(n) = n + $\theta(1)$ + n-k + $\theta(1)$ + n-2k + $\theta(1)$ + ... = $\frac{(n+k)*\frac{n}{k}}{2}$. Since k is a constant.\\
    Therefore, T(n) = $\theta(n^{2})$.
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    \end{solution}

    \part{} Solve the recurrence relation $T(n) = T(\alpha n) + T(\beta n) + \Theta(n)$ where $\alpha + \beta < 1$ and $\alpha \geq \beta$.
    \begin{subparts}
        \subpart[2] Fill in the \textbf{four} blanks in the mathematical derivation snippet below.
        \begin{align*}
            T(n) &= T(\alpha n) + T(\beta n) + \Theta(n) \\
                 &= (T(\alpha ^2 n) + T(\alpha \beta n) + \Theta(\alpha n)) +
                    (T(\alpha \beta n) + T(\beta ^2 n) + \Theta(\beta n)) + \Theta(n) \\
                 &= (T(\alpha ^2 n) + 2T(\alpha \beta n) + T(\beta ^2 n)) + \Theta(n) (1 + (\alpha + \beta)) \\
                 &= \dots \\
                 &= \sum _ {i=0} ^k {C_{k}^{i}} T({\alpha^{i} \beta^{k-i} n}) + \Theta(n) \sum _ {j = 0} ^{{k-1}} \sum _ {l = 0} ^{j} {C_{k-1}^{l}\alpha^{l} \beta^{k-1-l}}
        \end{align*}

        \subpart[3] Based on the previous part, complete this question.
        \begin{solution}
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Replace `\vspace{3in}' with your answer.
        Because T(n) = T($\alpha$n) + T($\beta$n) + $\theta(n)$, then the zero level is cn(c is a positive constant).\\
        The level 1 is c$\alpha n$ and c$\beta n$.\\
        The level 2 is c$\alpha^{2} n$ c$\alpha \beta n$ c$\alpha \beta n$ c$\beta^{2} n$.\\
        and so on\\
        Then we get the following series\\
        T(n) = $c(n + (\alpha + \beta)n + (\alpha + \beta)^{2}n + ... + ) = cn(\frac{1}{1-(\alpha + \beta)})$ because $\alpha + \beta < 1$.\\
        Therefore, T(n) = $\theta(n)$.
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        \end{solution}
    \end{subparts}

    \newpage
    
    \part[4] An algorithm $\mathcal{A}_3$ takes $\Theta(\log n)$ time to convert the original problem into 2 sub-problems, each one of size $\sqrt{n}$, then recursively runs itself on both of the 2 sub-problems and finally takes $\Theta(\log n)$ time to merge the answers of the 2 sub-problems.
    
    Hint: W.L.O.G., you may assume $n = 2^m$ for $m \in \mathbb{Z}$.
    \begin{solution}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Replace `\vspace{3in}' with your answer.
    1.T(n) = 2T($\sqrt{n}$) + $\theta(logn)$\\
    2.T(n) = O(lognloglogn)\\
    assume n = $2^{m}$ and it is transfromed to $A_{3}$ takes $\theta(m)$ time to convert the original problem into 2 sub-problems, each one of size $2^{\frac{m}{2}}$\\
    So T(n) is naturally transfromed into that $T(2^{m}) = T(2^{\frac{m}{2}}) + \theta(m)$.\\
    Then it equals the recursive tree that branching factor is 2, sub-problem size $\frac{n}{b}$ is $\frac{n}{2}$, the number of level is $log_{2}m$, so we get the series that T($2^{m}$) = $m + 2 * \frac{m}{2} + 2^{2} * (\frac{m}{2^{2}}) + ... + m*1 = m*log_{2}m$\\
    While n = $2^{m}$, then m = logn.\\
    i.e. T(n) = O(lognloglogn).
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    
    \end{solution}
\end{parts}